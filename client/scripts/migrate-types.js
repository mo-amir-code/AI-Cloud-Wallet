/* eslint-disable no-console */
const fs = require("fs");
const path = require("path");
const { Project } = require("ts-morph");

const baseDir = path.resolve(__dirname, "..");
const srcDir = path.join(baseDir, "src");
const typesRoot = path.join(srcDir, "types");

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function stripTsExt(p) {
  return p.replace(/\.(ts|tsx)$/, "");
}

function toModuleSpecifier(fromDir, toFileAbs) {
  let rel = path.relative(fromDir, toFileAbs).replace(/\\/g, "/");
  rel = stripTsExt(rel);
  if (!rel.startsWith(".")) rel = "./" + rel;
  return rel;
}

function upsertTypeImport(file, moduleSpecifier, names) {
  if (names.length === 0) return;
  const existing = file.getImportDeclarations().find(d => d.getModuleSpecifierValue() === moduleSpecifier && d.isTypeOnly());
  if (existing) {
    const current = new Set(existing.getNamedImports().map(n => n.getName()));
    names.forEach(n => {
      if (!current.has(n)) existing.addNamedImport(n);
    });
  } else {
    file.addImportDeclaration({
      isTypeOnly: true,
      moduleSpecifier,
      namedImports: names
    });
  }
}

function upsertTypeReExport(file, moduleSpecifier, names) {
  if (names.length === 0) return;
  const existing = file.getExportDeclarations().find(d => d.getModuleSpecifierValue() === moduleSpecifier && d.isTypeOnly());
  if (existing) {
    const current = new Set(existing.getNamedExports().map(n => n.getName()));
    names.forEach(n => {
      if (!current.has(n)) existing.addNamedExport(n);
    });
  } else {
    file.addExportDeclaration({
      isTypeOnly: true,
      moduleSpecifier,
      namedExports: names
    });
  }
}

(async () => {
  ensureDir(typesRoot);

  // Initialize project (tries tsconfig, falls back to manual add)
  let project;
  const tsconfigPath = path.join(baseDir, "tsconfig.json");
  if (fs.existsSync(tsconfigPath)) {
    project = new Project({ tsConfigFilePath: tsconfigPath, skipAddingFilesFromTsConfig: false });
  } else {
    project = new Project({ skipFileDependencyResolution: true, useInMemoryFileSystem: false });
    project.addSourceFilesAtPaths(["src/**/*.ts", "src/**/*.tsx"]);
  }

  const srcGlobs = ["src/**/*.ts", "src/**/*.tsx"];
  const files = project.getSourceFiles(srcGlobs).filter(f => {
    const p = f.getFilePath();
    if (p.endsWith(".d.ts")) return false;
    if (p.includes(path.sep + "src" + path.sep + "types" + path.sep)) return false;
    return true;
  });

  // Map: dirRelPath => Map<typeName, text>
  const dirToTypeTexts = new Map();

  let totalMoved = 0;

  for (const file of files) {
    const filePath = file.getFilePath();
    const fileDir = path.dirname(filePath);
    const dirRelPath = path.relative(srcDir, fileDir);
    const typeAliases = file.getTypeAliases();
    const interfaces = file.getInterfaces();

    // Collect declarations
    const decls = [];
    for (const d of [...typeAliases, ...interfaces]) {
      try {
        const name = d.getName();
        if (!name) continue;
        // Grab original text and normalize to exported
        let text = d.getText();
        const hasExport = d.hasExportKeyword && d.hasExportKeyword();
        if (!hasExport) {
          text = "export " + text;
        }
        decls.push({ name, text, node: d });
      } catch {
        // skip on any unexpected node error
      }
    }

    if (decls.length === 0) continue;

    // Prepare dir bucket
    const bucket = dirToTypeTexts.get(dirRelPath) || new Map();
    dirToTypeTexts.set(dirRelPath, bucket);

    // Insert into bucket with duplicate protection
    const toImportNames = [];
    for (const { name, text } of decls) {
      if (bucket.has(name)) {
        console.warn(`[skip duplicate] ${name} already exists in types for ${dirRelPath}, keeping the first occurrence.`);
        continue;
      }
      bucket.set(name, text);
      toImportNames.push(name);
    }

    // Remove declarations from original file
    for (const { node } of decls) node.remove();

    // Compute module spec to the mirrored types index
    const typesIndexAbs = path.join(typesRoot, dirRelPath, "index.ts");
    const modSpec = toModuleSpecifier(fileDir, typesIndexAbs);

    // Import type back for local usage and re-export to avoid breaking external imports
    upsertTypeImport(file, modSpec, toImportNames);
    upsertTypeReExport(file, modSpec, toImportNames);

    totalMoved += toImportNames.length;
  }

  // Write types index files
  for (const [dirRelPath, mapNameToText] of dirToTypeTexts.entries()) {
    const outDir = path.join(typesRoot, dirRelPath);
    ensureDir(outDir);
    const outFile = path.join(outDir, "index.ts");

    const header = `/* Auto-generated by scripts/migrate-types.js
 - This file aggregates type/interface declarations moved from src/${dirRelPath || "."}
 - Safe to edit after migration if needed.
*/\n\n`;

    const body = Array.from(mapNameToText.values()).join("\n\n") + "\n";
    fs.writeFileSync(outFile, header + body, "utf8");
    // Also add to project so it can format/save if needed
    if (!project.getSourceFile(outFile)) {
      project.addSourceFileAtPath(outFile);
    }
  }

  await project.save();

  console.log(`Types migrated: ${totalMoved}`);
  console.log(`Types root: ${path.relative(baseDir, typesRoot)}`);
  console.log("Done. Review changes with `git diff`.");
})().catch(err => {
  console.error(err);
  process.exit(1);
});
